# BOJ 1092번 배

## 문제 요약
항구에는 각각 무게 제한이 있는 크레인이 N대, 배에 옮겨야하는 M개의 박스가 있다. 크레인은 1분에 박스를 하나씩 배에 실을 수 있으며 모든 크레인은 동시에 움직인다.
무게 제한보다 무거운 박스는 크레인으로 움직일 수 없다.
모든 박스를 배로 옮기는데 드는 시간의 최솟값을 구하면 된다(만약 모든 박스를 배로 옮길 수 없으면 -1을 출력한다).

++) N은 50보다 작거나 같은 자연수, M은 10,000보다 작거나 같은 자연수이다.

## Naive한 접근
크레인의 무게 제한 정보를 저장한 cranes 리스트와 박스의 무게 정보를 저장한 boxes 리스트을 내림차순 정렬하여 각각의 크레인이 들 수 있는 가장 무거운 박스를 옮기도록 한다.

## Attempt 1 - Flawed Logic
그리디 방식을 시도하긴 했지만 내림차순 정렬된 boxes 정보를 deque 자료구조에 저장하여 옮기지 않은 박스 중 가장 무거운 박스에 대해서만 popleft를 통해 비교해 크레인이 들 수 있는 박스  중 가장 무거운 것을 드는 것이 아닌 들 수 없다면 break 하는 방식으로 구현하여 남은 크레인이 들 수 있는 박스가 있음에도 들지 않는 상황이 나오게 되어 "틀렸습니다"를 받았다.

## Attempt 2 - TLE
이미 옮긴 박스의 무게를 -1로 처리하여 다음에 넘어갈 수 있도록 하여 모든 크레인이 들 수 있는 박스 중 가장 무거운 것을 들 수 있도록 하였다. 그러나 제출하고 "시간초과"를 받았다. 생각해보니 이는 while문 안에 크레인, 박스 정보를 포함하는 리스트에 대한 이중 포문을 모든 박스를 옮길 때까지 반복하는 O(N*M²)의 시간복잡도를 가지기에 시간초과를 받을 수 밖에 없음을 알게되었다.

## - Attempt 3 - Accepted Solution
Attempt 2에서 pop연산을 사용하여 리스트에서 값의 옮김 때문에 발생하는 연산량이 클 것 같아 이미 옮긴 박스의 무게를 -1로 처리하였는데 조금 생각해보니 pop을 사용하는 것이 더 효율적이라는 것을 알 수 있었다. 최악의 경우인 하나의 크레인이 모든 박스를 옮기는 경우를 생각해보아도 M의 최대 제한인 10000을 통해 계산해보면 (10000/2)*10001 ≃ 50,000,000 번의 메모리 이동이 발생하여 시간 제한인 2초에 처리 가능한 연산량이다(사실 더 깊게가면 이것보다 더 복잡하게 생각해야할 것이다 / 파이썬 메모리 구조 등등..).

## 구현 포인트
while문 반복 조건을 인덱스가 리스트의 길이를 넘어가지 않을 때까지로 설정하여 경우 pop이 포함된 리스트의 인덱스 접근을 다음과 같이 하였다. pop한 경우 : 다음 크레인으로, pop하지 않은 경우 : 인덱스 + 1


